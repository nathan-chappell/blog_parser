# qa_es_index.py

from util import is_test
from qa_parser import QAParser, QAPair

import elasticsearch # type: ignore
from typing import Dict, Any, List
import copy
from itertools import product

es = elasticsearch.Elasticsearch([{'host':'localhost','port':9200}])

def parse_file(filename: str) -> List[QAPair]:
    parser = QAParser()
    return parser.parse_file(filename)

#
# All parameters for config are boolean
#
# @idx_q_stemmer: apply stemming to question field at index time
# @idx_a_stemmer: apply stemming to answer field at index time
# ...
#
class ES_CONFIG:
    # base name for index
    name_base: str

    # these parameters effect indexing
    idx_q_stemmer: bool
    idx_a_stemmer: bool
    qry_a_synonym: bool

    # these parameters effect the querying
    qry_q_fuzzy1: bool
    qry_a_fuzzy1: bool
    qry_q_boost: bool

    def __init__(self,
            name_base='qa_set',

            idx_q_stemmer = False,
            idx_a_stemmer = False,
            qry_a_synonym = False,

            qry_q_fuzzy1 = False,
            qry_a_fuzzy1 = False,
            qry_q_boost = False,
            ):

        self.name_base = name_base
        self.idx_q_stemmer = idx_q_stemmer 
        self.idx_a_stemmer = idx_a_stemmer 
        self.qry_q_fuzzy1 = qry_q_fuzzy1 
        self.qry_a_fuzzy1 = qry_a_fuzzy1 
        self.qry_q_boost = qry_q_boost 
        self.qry_a_synonym = qry_a_synonym 

    @property
    def index(self) -> str:
        """name of the index generated by this config"""
        iqs = ('' if self.idx_q_stemmer else 'no') + 'iqs'
        ias = ('' if self.idx_a_stemmer else 'no') + 'ias'
        qqf = ('' if self.qry_q_fuzzy1 else 'no') + 'iqf'
        qaf = ('' if self.qry_a_fuzzy1 else 'no') + 'iaf'
        qqb = ('' if self.qry_q_boost else 'no') + 'qqb'
        qas = ('' if self.qry_a_synonym else 'no') + 'qqs'

        return self.name_base + '_' + '-'.join([iqs,ias,qqf,qaf,qqb,qas])
    
    @property
    def settings(self) -> Dict[str,Any]:
        return { 
            'number_of_shards': 1,
            'analysis': self.analysis,
        }

    @property
    #def analysis(self) -> Dict[str,Any]:
    def analysis(self):
        base_analyzer = {
            'type': 'custom',
            'tokenizer': 'standard',
            'filter': [ 'lowercase', 'asciifolding', ]
        }

        filter_ = None

        question_analyzer = copy.deepcopy(base_analyzer)
        question_search_analyzer = copy.deepcopy(base_analyzer)
        answer_analyzer = copy.deepcopy(base_analyzer)
        answer_search_analyzer = copy.deepcopy(base_analyzer)

        if self.idx_q_stemmer:
            question_analyzer['filter'].append('porter_stem')
            question_search_analyzer['filter'].append('porter_stem')

        if self.idx_a_stemmer:
            answer_analyzer['filter'].append('porter_stem')
            answer_search_analyzer['filter'].append('porter_stem')

        if self.qry_a_synonym:
            answer_search_analyzer['filter'].append('synonym')
            filter_ = {
                'synonym': {
                    'type': 'synonym',
                    'synonyms_path': './synonyms.txt',
                }
            }

        analyzers = {
            'question_analyzer': question_analyzer,
            'question_search_analyzer': question_search_analyzer,
            'answer_analyzer': answer_analyzer,
            'answer_search_analyzer': question_search_analyzer,
        }

        analysis = {
            'analyzer': analyzers
        }

        if self.qry_a_synonym:
            analysis.update({'filter': filter_})

        return analysis

    @property
    def mappings(self) -> Dict[str,Any]:
        return {
            'properties': {
                'question': { 
                    'type': 'text',
                    'analyzer': 'question_analyzer',
                    'search_analyzer': 'question_search_analyzer',
                },
                'answer': { 
                    'type': 'text',
                    'analyzer': 'answer_analyzer',
                    'search_analyzer': 'answer_search_analyzer',
                },
                # the number is probably irrelevant, just pushing it through
                # for transparency's sake...
                'number': { 'type': 'text' },
            }
        }

    def create(self):
        index_config = {
            'settings': self.settings,
            'mappings': self.mappings,
        }
        es.indices.create(
            index=self.index,
            body=index_config
        )

    def delete(self):
        es.indices.delete(index=self.index)

def test_creation():
    B2 = [True,False]
    for x,y,z in product(*[B2]*3):
        config = ES_CONFIG('test',x,y,z)
        print(config.index)
        config.create()
        config.delete()

if __name__ == '__main__':
    if is_test(): test_creation()
